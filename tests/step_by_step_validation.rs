// Step-by-step validation tests for LMB/LMBM/Multisensor filters
//
// These tests validate EVERY intermediate step of the filter algorithms by comparing
// Rust outputs against MATLAB fixtures that capture inputs/outputs at each step.
//
// Fixtures generated by:
// - generateLmbStepByStepData.m
// - generateLmbmStepByStepData.m
// - generateMultisensorLmbStepByStepData.m
//
// This provides the deepest level of verification - if any step diverges from MATLAB,
// these tests will pinpoint the exact location.

use serde::Deserialize;
use std::fs;

// Import filter modules
use prak::lmb::cardinality;

const TOLERANCE: f64 = 1e-10; // Exact numerical equivalence

//=============================================================================
// LMB Step-by-Step Validation
//=============================================================================

#[derive(Debug, Deserialize)]
struct LmbFixture {
    seed: u64,
    timestep: usize,
    model: ModelData,
    measurements: Vec<Vec<f64>>,
    step1_prediction: PredictionStep,
    step2_association: AssociationStep,
    step3a_lbp: LbpStep,
    step3b_gibbs: GibbsStep,
    step3c_murtys: MurtysStep,
    step4_update: UpdateStep,
    step5_cardinality: CardinalityStep,
}

#[derive(Debug, Deserialize)]
struct ModelData {
    #[serde(rename = "A")]
    a: Vec<Vec<f64>>,
    #[serde(rename = "R")]
    r: Vec<Vec<f64>>,
    #[serde(rename = "C")]
    c: Vec<Vec<f64>>,
    #[serde(rename = "Q")]
    q: Vec<Vec<f64>>,
    #[serde(rename = "P_s")]
    p_s: f64,
    #[serde(rename = "P_d")]
    p_d: f64,
    clutter_per_unit_volume: f64,
}

#[derive(Debug, Deserialize)]
struct ObjectData {
    r: f64,
    label: Vec<usize>,
    mu: Vec<Vec<f64>>,
    #[serde(rename = "Sigma")]
    sigma: Vec<Vec<Vec<f64>>>,
    w: Vec<f64>,
}

#[derive(Debug, Deserialize)]
struct PredictionStep {
    input: PredictionInput,
    output: PredictionOutput,
}

#[derive(Debug, Deserialize)]
struct PredictionInput {
    prior_objects: Vec<ObjectData>,
    model_A: Vec<Vec<f64>>,
    model_R: Vec<Vec<f64>>,
    model_P_s: f64,
    timestep: usize,
}

#[derive(Debug, Deserialize)]
struct PredictionOutput {
    predicted_objects: Vec<ObjectData>,
}

#[derive(Debug, Deserialize)]
struct AssociationStep {
    input: AssociationInput,
    output: AssociationOutput,
}

#[derive(Debug, Deserialize)]
struct AssociationInput {
    predicted_objects: Vec<ObjectData>,
    measurements: Vec<Vec<f64>>,
    model_C: Vec<Vec<f64>>,
    model_Q: Vec<Vec<f64>>,
    model_P_d: f64,
    model_clutter: f64,
}

#[derive(Debug, Deserialize)]
struct AssociationOutput {
    #[serde(rename = "C")]
    c: Vec<Vec<f64>>,
    #[serde(rename = "L")]
    l: Vec<Vec<f64>>,
    #[serde(rename = "R")]
    r: Vec<Vec<f64>>,
    #[serde(rename = "P")]
    p: Vec<Vec<f64>>,
    eta: Vec<f64>,
    #[serde(rename = "posteriorParameters")]
    posterior_parameters: Vec<PosteriorParams>,
}

#[derive(Debug, Deserialize)]
struct PosteriorParams {
    mu: Vec<Vec<f64>>,
    #[serde(rename = "Sigma")]
    sigma: Vec<Vec<f64>>,
    w: Vec<f64>,
}

#[derive(Debug, Deserialize)]
struct LbpStep {
    input: LbpInput,
    output: LbpOutput,
}

#[derive(Debug, Deserialize)]
struct LbpInput {
    #[serde(rename = "C")]
    c: Vec<Vec<f64>>,
    #[serde(rename = "L")]
    l: Vec<Vec<f64>>,
    #[serde(rename = "R")]
    r: Vec<Vec<f64>>,
    #[serde(rename = "P")]
    p: Vec<Vec<f64>>,
    eta: Vec<f64>,
    convergence_tolerance: f64,
    max_iterations: usize,
}

#[derive(Debug, Deserialize)]
struct LbpOutput {
    r: Vec<f64>,
    #[serde(rename = "W")]
    w: Vec<Vec<f64>>,
}

#[derive(Debug, Deserialize)]
struct GibbsStep {
    input: GibbsInput,
    output: GibbsOutput,
}

#[derive(Debug, Deserialize)]
struct GibbsInput {
    #[serde(rename = "C")]
    c: Vec<Vec<f64>>,
    #[serde(rename = "L")]
    l: Vec<Vec<f64>>,
    #[serde(rename = "R")]
    r: Vec<Vec<f64>>,
    #[serde(rename = "P")]
    p: Vec<Vec<f64>>,
    eta: Vec<f64>,
    #[serde(rename = "numberOfSamples")]
    number_of_samples: usize,
    rng_seed: u64,
}

#[derive(Debug, Deserialize)]
struct GibbsOutput {
    r: Vec<f64>,
    #[serde(rename = "W")]
    w: Vec<Vec<f64>>,
}

#[derive(Debug, Deserialize)]
struct MurtysStep {
    input: MurtysInput,
    output: MurtysOutput,
}

#[derive(Debug, Deserialize)]
struct MurtysInput {
    #[serde(rename = "C")]
    c: Vec<Vec<f64>>,
    #[serde(rename = "L")]
    l: Vec<Vec<f64>>,
    #[serde(rename = "R")]
    r: Vec<Vec<f64>>,
    #[serde(rename = "P")]
    p: Vec<Vec<f64>>,
    eta: Vec<f64>,
    #[serde(rename = "numberOfAssignments")]
    number_of_assignments: usize,
}

#[derive(Debug, Deserialize)]
struct MurtysOutput {
    r: Vec<f64>,
    #[serde(rename = "W")]
    w: Vec<Vec<f64>>,
}

#[derive(Debug, Deserialize)]
struct UpdateStep {
    input: UpdateInput,
    output: UpdateOutput,
}

#[derive(Debug, Deserialize)]
struct UpdateInput {
    predicted_objects: Vec<ObjectData>,
    r: Vec<f64>,
    #[serde(rename = "W")]
    w: Vec<Vec<f64>>,
    #[serde(rename = "posteriorParameters")]
    posterior_parameters: Vec<PosteriorParams>,
    model_C: Vec<Vec<f64>>,
    model_Q: Vec<Vec<f64>>,
}

#[derive(Debug, Deserialize)]
struct UpdateOutput {
    posterior_objects: Vec<ObjectData>,
}

#[derive(Debug, Deserialize)]
struct CardinalityStep {
    input: CardinalityInput,
    output: CardinalityOutput,
}

#[derive(Debug, Deserialize)]
struct CardinalityInput {
    existence_probs: Vec<f64>,
}

#[derive(Debug, Deserialize)]
struct CardinalityOutput {
    n_estimated: usize,
    map_indices: Vec<usize>,
}

// Helper functions
fn assert_vec_close(a: &[f64], b: &[f64], tolerance: f64, msg: &str) {
    assert_eq!(a.len(), b.len(), "{}: length mismatch", msg);
    for (i, (av, bv)) in a.iter().zip(b.iter()).enumerate() {
        let diff = (av - bv).abs();
        assert!(
            diff <= tolerance,
            "{}: element {} differs: {} vs {} (diff: {})",
            msg,
            i,
            av,
            bv,
            diff
        );
    }
}

fn assert_matrix_close(a: &[Vec<f64>], b: &[Vec<f64>], tolerance: f64, msg: &str) {
    assert_eq!(a.len(), b.len(), "{}: row count mismatch", msg);
    for (i, (arow, brow)) in a.iter().zip(b.iter()).enumerate() {
        assert_vec_close(arow, brow, tolerance, &format!("{} row {}", msg, i));
    }
}

// Convert MATLAB 1-indexed to Rust 0-indexed
fn matlab_to_rust_indices(indices: &[usize]) -> Vec<usize> {
    indices.iter().map(|&i| i - 1).collect()
}

#[test]
fn test_lmb_step_by_step_validation() {
    // Load fixture
    let fixture_path = "tests/data/step_by_step/lmb_step_by_step_seed42.json";
    let fixture_data = fs::read_to_string(fixture_path)
        .unwrap_or_else(|e| panic!("Failed to read fixture {}: {}", fixture_path, e));
    let fixture: LmbFixture = serde_json::from_str(&fixture_data)
        .unwrap_or_else(|e| panic!("Failed to parse fixture: {}", e));

    println!("Testing LMB step-by-step validation (timestep {})", fixture.timestep);

    // Step 1: Prediction
    println!("  [1/5] Validating prediction step...");
    validate_lmb_prediction(&fixture);

    // Step 2: Association matrices
    println!("  [2/5] Validating association matrices...");
    validate_lmb_association(&fixture);

    // Step 3a: LBP data association
    println!("  [3a/5] Validating LBP data association...");
    validate_lmb_lbp(&fixture);

    // Step 3b: Gibbs data association
    println!("  [3b/5] Validating Gibbs data association...");
    validate_lmb_gibbs(&fixture);

    // Step 3c: Murty's data association
    println!("  [3c/5] Validating Murty's data association...");
    validate_lmb_murtys(&fixture);

    // Step 4: Update
    println!("  [4/5] Validating update step...");
    validate_lmb_update(&fixture);

    // Step 5: Cardinality estimation
    println!("  [5/5] Validating cardinality estimation...");
    validate_lmb_cardinality(&fixture);

    println!("✓ All LMB step-by-step validations passed");
}

fn validate_lmb_prediction(fixture: &LmbFixture) {
    // TODO: Implement LMB prediction validation
    // This requires converting fixture data to Rust types and calling lmb::prediction::lmb_prediction_step
    println!("    LMB prediction validation: TODO");
}

fn validate_lmb_association(fixture: &LmbFixture) {
    // TODO: Implement LMB association validation
    println!("    LMB association validation: TODO");
}

fn validate_lmb_lbp(fixture: &LmbFixture) {
    // TODO: Implement LBP validation
    println!("    LBP validation: TODO");
}

fn validate_lmb_gibbs(fixture: &LmbFixture) {
    // TODO: Implement Gibbs validation
    println!("    Gibbs validation: TODO");
}

fn validate_lmb_murtys(fixture: &LmbFixture) {
    // TODO: Implement Murty's validation
    println!("    Murty's validation: TODO");
}

fn validate_lmb_update(fixture: &LmbFixture) {
    // TODO: Implement update validation
    println!("    Update validation: TODO");
}

fn validate_lmb_cardinality(fixture: &LmbFixture) {
    // Cardinality estimation is straightforward - just call the function
    let existence_probs = &fixture.step5_cardinality.input.existence_probs;
    let expected_n = fixture.step5_cardinality.output.n_estimated;
    let expected_indices = matlab_to_rust_indices(&fixture.step5_cardinality.output.map_indices);

    let (actual_n, actual_indices) = cardinality::lmb_map_cardinality_estimate(existence_probs);

    assert_eq!(actual_n, expected_n, "Cardinality estimate mismatch");
    assert_eq!(
        actual_indices, expected_indices,
        "MAP indices mismatch"
    );

    println!("    ✓ Cardinality validation passed (n={}, indices={:?})", actual_n, actual_indices);
}
