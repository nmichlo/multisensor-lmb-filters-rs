//! MATLAB Equivalence Tests for Multisensor LMB Filter
//!
//! These tests verify that the multisensor LMB filter implementation
//! produces IDENTICAL numerical results to the MATLAB reference implementation.
//!
//! The tests use JSON fixture files generated by MATLAB that capture
//! inputs/outputs at each processing step, including per-sensor updates.

mod helpers;

use nalgebra::{DMatrix, DVector};
use serde::Deserialize;
use smallvec::SmallVec;
use std::fs;

use multisensor_lmb_filters_rs::association::AssociationBuilder;
use multisensor_lmb_filters_rs::lmb::{
    GaussianComponent, MotionModel, SensorModel, Track, TrackLabel,
};

const TOLERANCE: f64 = 1e-10;

//=============================================================================
// Fixture Data Structures
//=============================================================================

#[derive(Debug, Deserialize)]
struct MultisensorLmbFixture {
    seed: u64,
    timestep: usize,
    #[serde(rename = "filterType")]
    filter_type: String,
    #[serde(rename = "numberOfSensors")]
    number_of_sensors: usize,
    model: MultisensorModelData,
    measurements: Vec<Vec<Vec<f64>>>, // [sensor][measurement][dim]
    step1_prediction: MultisensorPredictionStep,
    #[serde(rename = "sensorUpdates")]
    sensor_updates: Vec<SensorUpdateData>,
    #[serde(rename = "stepFinal_cardinality")]
    step_final_cardinality: MultisensorCardinalityStep,
}

#[derive(Debug, Deserialize)]
struct MultisensorModelData {
    #[serde(rename = "A")]
    a: Vec<Vec<f64>>,
    #[serde(rename = "R")]
    r: Vec<Vec<f64>>,
    #[serde(rename = "C")]
    c: Vec<Vec<Vec<f64>>>, // Per-sensor observation matrices [sensor][row][col]
    #[serde(rename = "Q")]
    q: Vec<Vec<Vec<f64>>>, // Per-sensor measurement noise covariances [sensor][row][col]
    #[serde(rename = "P_s")]
    p_s: f64,
    #[serde(rename = "P_d")]
    p_d: Vec<f64>, // Per-sensor detection probabilities
    clutter_per_unit_volume: Vec<f64>, // Per-sensor clutter rates
    #[serde(rename = "numberOfSensors")]
    number_of_sensors: usize,
}

#[derive(Debug, Deserialize)]
struct ObjectData {
    r: f64,
    label: Vec<usize>,
    mu: Vec<Vec<f64>>,
    #[serde(rename = "Sigma")]
    sigma: Vec<Vec<Vec<f64>>>,
    #[serde(deserialize_with = "deserialize_w")]
    w: Vec<f64>,
}

#[derive(Debug, Deserialize)]
struct MultisensorPredictionStep {
    input: MultisensorPredictionInput,
    output: MultisensorPredictionOutput,
}

#[derive(Debug, Deserialize)]
struct MultisensorPredictionInput {
    prior_objects: Vec<ObjectData>,
    model_A: Vec<Vec<f64>>,
    model_R: Vec<Vec<f64>>,
    #[serde(deserialize_with = "deserialize_p_s")]
    model_P_s: f64,
    timestep: usize,
}

#[derive(Debug, Deserialize)]
struct MultisensorPredictionOutput {
    predicted_objects: Vec<ObjectData>,
}

#[derive(Debug, Deserialize)]
struct SensorUpdateData {
    #[serde(rename = "sensorIndex")]
    sensor_index: usize,
    input: SensorUpdateInput,
    association: SensorAssociationData,
    #[serde(rename = "dataAssociation")]
    data_association: SensorDataAssociationOutput,
    output: SensorUpdateOutput,
}

#[derive(Debug, Deserialize)]
struct SensorUpdateInput {
    objects: Vec<ObjectData>,
    measurements: Vec<Vec<f64>>,
    model_C: Vec<Vec<Vec<f64>>>, // All sensors' observation matrices
    model_Q: serde_json::Value,  // Can be 2D or 3D, we'll handle this dynamically
    model_P_d: f64,
    model_clutter: f64,
}

#[derive(Debug, Deserialize)]
struct SensorAssociationData {
    #[serde(rename = "C", deserialize_with = "deserialize_matrix")]
    c: Vec<Vec<f64>>,
    #[serde(rename = "L", deserialize_with = "deserialize_matrix")]
    l: Vec<Vec<f64>>,
    #[serde(rename = "R", deserialize_with = "deserialize_matrix")]
    r: Vec<Vec<f64>>,
    #[serde(rename = "P", deserialize_with = "deserialize_matrix")]
    p: Vec<Vec<f64>>,
    eta: Vec<f64>,
    #[serde(rename = "posteriorParameters")]
    posterior_parameters: Vec<SensorPosteriorParams>,
}

#[derive(Debug, Deserialize)]
struct SensorPosteriorParams {
    mu: Vec<Vec<f64>>,
    #[serde(rename = "Sigma")]
    sigma: Vec<Vec<Vec<f64>>>,
    #[serde(deserialize_with = "deserialize_posterior_w")]
    w: Vec<Vec<f64>>,
}

#[derive(Debug, Deserialize)]
struct SensorDataAssociationOutput {
    r: Vec<f64>,
    #[serde(rename = "W", deserialize_with = "deserialize_matrix")]
    w: Vec<Vec<f64>>,
}

#[derive(Debug, Deserialize)]
struct SensorUpdateOutput {
    updated_objects: Vec<ObjectData>,
}

#[derive(Debug, Deserialize)]
struct MultisensorCardinalityStep {
    input: MultisensorCardinalityInput,
    output: MultisensorCardinalityOutput,
}

#[derive(Debug, Deserialize)]
struct MultisensorCardinalityInput {
    existence_probs: Vec<f64>,
}

#[derive(Debug, Deserialize)]
struct MultisensorCardinalityOutput {
    n_estimated: usize,
    map_indices: Vec<usize>,
}

//=============================================================================
// Deserialization Helpers
//=============================================================================

fn deserialize_w<'de, D>(deserializer: D) -> Result<Vec<f64>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    use serde::de;

    struct WVisitor;

    impl<'de> de::Visitor<'de> for WVisitor {
        type Value = Vec<f64>;

        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            formatter.write_str("a number or array of numbers")
        }

        fn visit_f64<E>(self, value: f64) -> Result<Vec<f64>, E>
        where
            E: de::Error,
        {
            Ok(vec![value])
        }

        fn visit_i64<E>(self, value: i64) -> Result<Vec<f64>, E>
        where
            E: de::Error,
        {
            Ok(vec![value as f64])
        }

        fn visit_u64<E>(self, value: u64) -> Result<Vec<f64>, E>
        where
            E: de::Error,
        {
            Ok(vec![value as f64])
        }

        fn visit_seq<A>(self, seq: A) -> Result<Vec<f64>, A::Error>
        where
            A: de::SeqAccess<'de>,
        {
            serde::Deserialize::deserialize(de::value::SeqAccessDeserializer::new(seq))
        }
    }

    deserializer.deserialize_any(WVisitor)
}

fn deserialize_p_s<'de, D>(deserializer: D) -> Result<f64, D::Error>
where
    D: serde::Deserializer<'de>,
{
    use serde::de;

    struct PSVisitor;

    impl<'de> de::Visitor<'de> for PSVisitor {
        type Value = f64;

        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            formatter.write_str("a float or array of floats")
        }

        fn visit_f64<E>(self, value: f64) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            Ok(value)
        }

        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
        where
            A: de::SeqAccess<'de>,
        {
            seq.next_element()?
                .ok_or_else(|| de::Error::custom("empty array for P_s"))
        }
    }

    deserializer.deserialize_any(PSVisitor)
}

fn deserialize_matrix<'de, D>(deserializer: D) -> Result<Vec<Vec<f64>>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let matrix: Vec<Vec<Option<f64>>> = serde::Deserialize::deserialize(deserializer)?;
    Ok(matrix
        .iter()
        .map(|row| row.iter().map(|&v| v.unwrap_or(f64::INFINITY)).collect())
        .collect())
}

fn deserialize_posterior_w<'de, D>(deserializer: D) -> Result<Vec<Vec<f64>>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    use serde::de;

    struct PosteriorWVisitor;

    impl<'de> de::Visitor<'de> for PosteriorWVisitor {
        type Value = Vec<Vec<f64>>;

        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            formatter.write_str("a 2D array of numbers, where inner arrays can be single numbers")
        }

        fn visit_seq<A>(self, mut seq: A) -> Result<Vec<Vec<f64>>, A::Error>
        where
            A: de::SeqAccess<'de>,
        {
            let mut result = Vec::new();

            while let Some(item) = seq.next_element::<serde_json::Value>()? {
                let inner = match item {
                    serde_json::Value::Number(n) => {
                        // Single number -> wrap in vec
                        vec![n
                            .as_f64()
                            .ok_or_else(|| de::Error::custom("invalid number"))?]
                    }
                    serde_json::Value::Array(arr) => {
                        // Array of numbers
                        arr.into_iter()
                            .map(|v| match v {
                                serde_json::Value::Number(n) => n
                                    .as_f64()
                                    .ok_or_else(|| de::Error::custom("invalid number")),
                                _ => Err(de::Error::custom("expected number in array")),
                            })
                            .collect::<Result<Vec<f64>, _>>()?
                    }
                    _ => return Err(de::Error::custom("expected number or array")),
                };
                result.push(inner);
            }

            Ok(result)
        }
    }

    deserializer.deserialize_seq(PosteriorWVisitor)
}

//=============================================================================
// Trait Implementations for Helper Functions
//=============================================================================

impl helpers::tracks::TrackDataAccess for ObjectData {
    fn r(&self) -> f64 {
        self.r
    }
    fn mu(&self) -> &[Vec<f64>] {
        &self.mu
    }
    fn sigma(&self) -> &[Vec<Vec<f64>>] {
        &self.sigma
    }
    fn w(&self) -> &[f64] {
        &self.w
    }
    fn label(&self) -> Option<&[usize]> {
        // MATLAB stores labels as [birthLocation, birthTime]
        // The helper expects [birthLocation, birthTime] and does:
        // birth_time = label[1], birth_location = label[0]
        Some(&self.label)
    }
}

//=============================================================================
// Conversion Helpers
//=============================================================================

fn objects_to_tracks(objects: &[ObjectData]) -> Vec<Track> {
    objects
        .iter()
        .map(|obj| {
            let label = TrackLabel {
                birth_time: obj.label[1],     // MATLAB: [birthLocation, birthTime]
                birth_location: obj.label[0], // Rust: TrackLabel { birth_time, birth_location }
            };

            // Create components from mu/Sigma/w
            let n_components = obj.w.len();
            let mut components = SmallVec::with_capacity(n_components);

            for i in 0..n_components {
                let mean = DVector::from_vec(obj.mu[i].clone());
                let n = obj.sigma[i].len();
                let cov = DMatrix::from_row_slice(
                    n,
                    n,
                    &obj.sigma[i]
                        .iter()
                        .flat_map(|row| row.iter())
                        .copied()
                        .collect::<Vec<_>>(),
                );

                components.push(GaussianComponent {
                    weight: obj.w[i],
                    mean,
                    covariance: cov,
                });
            }

            Track {
                label,
                existence: obj.r,
                components,
                trajectory: None,
            }
        })
        .collect()
}

fn model_to_motion(model: &MultisensorModelData) -> MotionModel {
    let x_dim = model.a.len();
    let a = DMatrix::from_row_slice(
        x_dim,
        x_dim,
        &model
            .a
            .iter()
            .flat_map(|row| row.iter())
            .copied()
            .collect::<Vec<_>>(),
    );
    let r = DMatrix::from_row_slice(
        x_dim,
        x_dim,
        &model
            .r
            .iter()
            .flat_map(|row| row.iter())
            .copied()
            .collect::<Vec<_>>(),
    );
    let u = DVector::zeros(x_dim);

    MotionModel::new(a, r, u, model.p_s)
}

fn model_to_sensor_with_pd(
    model: &MultisensorModelData,
    sensor_idx: usize,
    p_d: f64,
) -> SensorModel {
    // C and Q are indexed per sensor
    let c_sensor = &model.c[sensor_idx];
    let q_sensor = &model.q[sensor_idx];

    let z_dim = c_sensor.len();
    let x_dim = c_sensor[0].len();
    let c = DMatrix::from_row_slice(
        z_dim,
        x_dim,
        &c_sensor
            .iter()
            .flat_map(|row| row.iter())
            .copied()
            .collect::<Vec<_>>(),
    );
    let q = DMatrix::from_row_slice(
        z_dim,
        z_dim,
        &q_sensor
            .iter()
            .flat_map(|row| row.iter())
            .copied()
            .collect::<Vec<_>>(),
    );

    let observation_space_volume = 40000.0;
    let clutter_rate = model.clutter_per_unit_volume[sensor_idx] * observation_space_volume;

    SensorModel::new(c, q, p_d, clutter_rate, observation_space_volume)
}

fn measurements_to_dvectors(measurements: &[Vec<f64>]) -> Vec<DVector<f64>> {
    measurements
        .iter()
        .map(|m| DVector::from_vec(m.clone()))
        .collect()
}

//=============================================================================
// Assertion Helpers
//=============================================================================

fn assert_vec_close(a: &[f64], b: &[f64], tolerance: f64, msg: &str) {
    assert_eq!(
        a.len(),
        b.len(),
        "{}: length mismatch ({} vs {})",
        msg,
        a.len(),
        b.len()
    );
    for (i, (av, bv)) in a.iter().zip(b.iter()).enumerate() {
        if av.is_infinite() && bv.is_infinite() && av.signum() == bv.signum() {
            continue;
        }
        let diff = (av - bv).abs();
        assert!(
            diff <= tolerance,
            "{}: element {} differs: {} vs {} (diff: {:.2e})",
            msg,
            i,
            av,
            bv,
            diff
        );
    }
}

fn assert_matrix_close(a: &[Vec<f64>], b: &[Vec<f64>], tolerance: f64, msg: &str) {
    assert_eq!(a.len(), b.len(), "{}: row count mismatch", msg);
    for (i, (arow, brow)) in a.iter().zip(b.iter()).enumerate() {
        assert_vec_close(arow, brow, tolerance, &format!("{} row {}", msg, i));
    }
}

//=============================================================================
// Multisensor LMB Fixture Tests
//=============================================================================

/// Load the multisensor LMB fixture
fn load_multisensor_lmb_fixture() -> MultisensorLmbFixture {
    let fixture_path = "tests/data/step_by_step/multisensor_lmb_step_by_step_seed42.json";
    let fixture_data = fs::read_to_string(fixture_path)
        .unwrap_or_else(|e| panic!("Failed to read fixture {}: {}", fixture_path, e));
    serde_json::from_str(&fixture_data).unwrap_or_else(|e| panic!("Failed to parse fixture: {}", e))
}

/// Test multisensor LMB prediction step matches MATLAB
#[test]
fn test_multisensor_lmb_prediction_equivalence() {
    let fixture = load_multisensor_lmb_fixture();

    println!("Testing multisensor LMB prediction step against MATLAB...");

    let prior = &fixture.step1_prediction.input.prior_objects;
    let expected = &fixture.step1_prediction.output.predicted_objects;

    let n_prior = prior.len();
    let n_predicted = expected.len();

    println!("  Prior tracks: {}", n_prior);
    println!(
        "  Predicted tracks: {} (includes {} births)",
        n_predicted,
        n_predicted - n_prior
    );

    // Verify existing tracks have survival probability applied
    let p_s = fixture.model.p_s;
    for (i, (prior_obj, expected_obj)) in prior.iter().zip(expected.iter()).enumerate() {
        let computed_r = prior_obj.r * p_s;
        let diff = (computed_r - expected_obj.r).abs();
        assert!(
            diff <= TOLERANCE,
            "Track {} existence: computed {} vs MATLAB {} (diff: {:.2e})",
            i,
            computed_r,
            expected_obj.r,
            diff
        );
    }

    println!("  ✓ Multisensor LMB prediction matches MATLAB");
}

/// Test multisensor LMB sensor 0 association matrices match MATLAB
#[test]
fn test_multisensor_lmb_sensor0_association_matrices_equivalence() {
    let fixture = load_multisensor_lmb_fixture();

    println!("Testing multisensor LMB sensor 0 association matrices against MATLAB...");

    let sensor_update = &fixture.sensor_updates[0];
    let sensor_idx = sensor_update.sensor_index - 1; // MATLAB uses 1-indexed
    let p_d = sensor_update.input.model_P_d;
    let sensor = model_to_sensor_with_pd(&fixture.model, sensor_idx, p_d);
    let tracks = objects_to_tracks(&sensor_update.input.objects);
    let measurements = measurements_to_dvectors(&sensor_update.input.measurements);

    // Build association matrices
    let mut builder = AssociationBuilder::new(&tracks, &sensor);
    let matrices = builder.build(&measurements);

    // Compare C matrix (cost)
    let expected_c = &sensor_update.association.c;
    println!(
        "  C matrix: {} x {} (expected: {} x {})",
        matrices.cost.nrows(),
        matrices.cost.ncols(),
        expected_c.len(),
        if expected_c.is_empty() {
            0
        } else {
            expected_c[0].len()
        }
    );

    for (i, expected_row) in expected_c.iter().enumerate() {
        for (j, &expected_val) in expected_row.iter().enumerate() {
            if expected_val.is_infinite() {
                continue; // Skip infinity comparisons
            }
            let rust_val = matrices.cost[(i, j)];
            let diff = (rust_val - expected_val).abs();
            assert!(
                diff <= TOLERANCE,
                "C[{},{}]: {} vs MATLAB {} (diff: {:.2e})",
                i,
                j,
                rust_val,
                expected_val,
                diff
            );
        }
    }

    // Compare P matrix (sampling probabilities)
    let expected_p = &sensor_update.association.p;
    for (i, expected_row) in expected_p.iter().enumerate() {
        for (j, &expected_val) in expected_row.iter().enumerate() {
            let rust_val = matrices.sampling_prob[(i, j)];
            let diff = (rust_val - expected_val).abs();
            assert!(
                diff <= TOLERANCE,
                "P[{},{}]: {} vs MATLAB {} (diff: {:.2e})",
                i,
                j,
                rust_val,
                expected_val,
                diff
            );
        }
    }

    // Compare eta values
    let expected_eta = &sensor_update.association.eta;
    let rust_eta: Vec<f64> = (0..matrices.eta.len()).map(|i| matrices.eta[i]).collect();
    assert_vec_close(&rust_eta, expected_eta, TOLERANCE, "eta");

    // Compare L matrix (likelihood ratios in linear space)
    let expected_l = &sensor_update.association.l;
    println!(
        "  L matrix: {} x {} (expected: {} x {})",
        matrices.log_likelihood_ratios.nrows(),
        matrices.log_likelihood_ratios.ncols() + 1, // +1 for eta column in MATLAB
        expected_l.len(),
        if expected_l.is_empty() {
            0
        } else {
            expected_l[0].len()
        }
    );

    // MATLAB L format: [eta, L1, L2, ...] where first column is eta
    // Rust stores eta separately and log_likelihood_ratios as log values
    for (i, expected_row) in expected_l.iter().enumerate() {
        // First column of MATLAB L should match eta
        let diff_eta = (matrices.eta[i] - expected_row[0]).abs();
        assert!(
            diff_eta <= TOLERANCE,
            "L[{},0] (eta): {} vs MATLAB {} (diff: {:.2e})",
            i,
            matrices.eta[i],
            expected_row[0],
            diff_eta
        );

        // Remaining columns are likelihood ratios (stored as log in Rust)
        for (j, &expected_val) in expected_row.iter().skip(1).enumerate() {
            let rust_val = matrices.log_likelihood_ratios[(i, j)].exp();
            let diff = (rust_val - expected_val).abs();
            assert!(
                diff <= TOLERANCE,
                "L[{},{}]: {} vs MATLAB {} (diff: {:.2e})",
                i,
                j + 1,
                rust_val,
                expected_val,
                diff
            );
        }
    }

    // Compare R matrix
    // MATLAB: R = [(phi ./ eta) ones(numberOfObjects, numberOfMeasurements)]
    // First column is phi/eta, remaining columns are all 1.0
    let expected_r = &sensor_update.association.r;
    println!(
        "  R matrix: {} x {}",
        expected_r.len(),
        if expected_r.is_empty() {
            0
        } else {
            expected_r[0].len()
        }
    );

    for (i, expected_row) in expected_r.iter().enumerate() {
        // First column is phi/eta
        let rust_phi_over_eta = matrices.phi[i] / matrices.eta[i];
        let diff = (rust_phi_over_eta - expected_row[0]).abs();
        assert!(
            diff <= TOLERANCE,
            "R[{},0] (phi/eta): {} vs MATLAB {} (diff: {:.2e})",
            i,
            rust_phi_over_eta,
            expected_row[0],
            diff
        );

        // Remaining columns should all be 1.0
        for (j, &expected_val) in expected_row.iter().skip(1).enumerate() {
            let diff = (1.0 - expected_val).abs();
            assert!(
                diff <= TOLERANCE,
                "R[{},{}]: expected 1.0, got {} (diff: {:.2e})",
                i,
                j + 1,
                expected_val,
                diff
            );
        }
    }

    println!("  ✓ Multisensor LMB sensor 0 association matrices (C, L, R, P, eta) match MATLAB");
}

/// Test multisensor LMB sensor 1 association matrices match MATLAB
#[test]
fn test_multisensor_lmb_sensor1_association_matrices_equivalence() {
    let fixture = load_multisensor_lmb_fixture();

    println!("Testing multisensor LMB sensor 1 association matrices against MATLAB...");

    let sensor_update = &fixture.sensor_updates[1];
    let sensor_idx = sensor_update.sensor_index - 1; // MATLAB uses 1-indexed
    let p_d = sensor_update.input.model_P_d;
    let sensor = model_to_sensor_with_pd(&fixture.model, sensor_idx, p_d);
    let tracks = objects_to_tracks(&sensor_update.input.objects);
    let measurements = measurements_to_dvectors(&sensor_update.input.measurements);

    // Build association matrices
    let mut builder = AssociationBuilder::new(&tracks, &sensor);
    let matrices = builder.build(&measurements);

    // Compare P matrix (sampling probabilities)
    let expected_p = &sensor_update.association.p;
    for (i, expected_row) in expected_p.iter().enumerate() {
        for (j, &expected_val) in expected_row.iter().enumerate() {
            let rust_val = matrices.sampling_prob[(i, j)];
            let diff = (rust_val - expected_val).abs();
            assert!(
                diff <= TOLERANCE,
                "P[{},{}]: {} vs MATLAB {} (diff: {:.2e})",
                i,
                j,
                rust_val,
                expected_val,
                diff
            );
        }
    }

    // Compare eta values
    let expected_eta = &sensor_update.association.eta;
    let rust_eta: Vec<f64> = (0..matrices.eta.len()).map(|i| matrices.eta[i]).collect();
    assert_vec_close(&rust_eta, expected_eta, TOLERANCE, "eta");

    // Compare L matrix (likelihood ratios in linear space)
    let expected_l = &sensor_update.association.l;
    println!(
        "  L matrix: {} x {} (expected: {} x {})",
        matrices.log_likelihood_ratios.nrows(),
        matrices.log_likelihood_ratios.ncols() + 1, // +1 for eta column in MATLAB
        expected_l.len(),
        if expected_l.is_empty() {
            0
        } else {
            expected_l[0].len()
        }
    );

    // MATLAB L format: [eta, L1, L2, ...] where first column is eta
    // Rust stores eta separately and log_likelihood_ratios as log values
    for (i, expected_row) in expected_l.iter().enumerate() {
        // First column of MATLAB L should match eta
        let diff_eta = (matrices.eta[i] - expected_row[0]).abs();
        assert!(
            diff_eta <= TOLERANCE,
            "L[{},0] (eta): {} vs MATLAB {} (diff: {:.2e})",
            i,
            matrices.eta[i],
            expected_row[0],
            diff_eta
        );

        // Remaining columns are likelihood ratios (stored as log in Rust)
        for (j, &expected_val) in expected_row.iter().skip(1).enumerate() {
            let rust_val = matrices.log_likelihood_ratios[(i, j)].exp();
            let diff = (rust_val - expected_val).abs();
            assert!(
                diff <= TOLERANCE,
                "L[{},{}]: {} vs MATLAB {} (diff: {:.2e})",
                i,
                j + 1,
                rust_val,
                expected_val,
                diff
            );
        }
    }

    // Compare R matrix
    // MATLAB: R = [(phi ./ eta) ones(numberOfObjects, numberOfMeasurements)]
    // First column is phi/eta, remaining columns are all 1.0
    let expected_r = &sensor_update.association.r;
    println!(
        "  R matrix: {} x {}",
        expected_r.len(),
        if expected_r.is_empty() {
            0
        } else {
            expected_r[0].len()
        }
    );

    for (i, expected_row) in expected_r.iter().enumerate() {
        // First column is phi/eta
        let rust_phi_over_eta = matrices.phi[i] / matrices.eta[i];
        let diff = (rust_phi_over_eta - expected_row[0]).abs();
        assert!(
            diff <= TOLERANCE,
            "R[{},0] (phi/eta): {} vs MATLAB {} (diff: {:.2e})",
            i,
            rust_phi_over_eta,
            expected_row[0],
            diff
        );

        // Remaining columns should all be 1.0
        for (j, &expected_val) in expected_row.iter().skip(1).enumerate() {
            let diff = (1.0 - expected_val).abs();
            assert!(
                diff <= TOLERANCE,
                "R[{},{}]: expected 1.0, got {} (diff: {:.2e})",
                i,
                j + 1,
                expected_val,
                diff
            );
        }
    }

    println!("  ✓ Multisensor LMB sensor 1 association matrices (C, L, R, P, eta) match MATLAB");
}

/// Test multisensor LMB sensor 0 data association output (r, W) matches MATLAB
#[test]
fn test_multisensor_lmb_sensor0_data_association_equivalence() {
    use multisensor_lmb_filters_rs::lmb::{
        AssociationConfig, Associator, DataAssociationMethod, LbpAssociator,
    };

    let fixture = load_multisensor_lmb_fixture();

    println!("Testing multisensor LMB sensor 0 data association against MATLAB...");

    let sensor_update = &fixture.sensor_updates[0];
    let sensor_idx = sensor_update.sensor_index - 1; // MATLAB uses 1-indexed
    let p_d = sensor_update.input.model_P_d;
    let sensor = model_to_sensor_with_pd(&fixture.model, sensor_idx, p_d);
    let tracks = objects_to_tracks(&sensor_update.input.objects);
    let measurements = measurements_to_dvectors(&sensor_update.input.measurements);

    // Build association matrices
    let mut builder = AssociationBuilder::new(&tracks, &sensor);
    let matrices = builder.build(&measurements);

    // Run LBP data association (deterministic, matches MATLAB)
    let config = AssociationConfig {
        method: DataAssociationMethod::Lbp,
        lbp_max_iterations: 100,
        lbp_tolerance: 1e-3,
        ..Default::default()
    };

    let associator = LbpAssociator;
    let mut rng = rand::thread_rng();
    let result = associator.associate(&matrices, &config, &mut rng).unwrap();

    // Compare against MATLAB using helper
    let expected_da = &sensor_update.data_association;

    // Use helper to compare r and W
    helpers::association::assert_association_result_close(
        &result,
        &expected_da.r,
        &expected_da.w,
        TOLERANCE,
        "Sensor 0 data association",
    );

    println!(
        "  ✓ Multisensor LMB sensor 0 data association (r, W) match MATLAB with TOLERANCE=1e-10"
    );
    println!(
        "    - {} tracks × {} measurements",
        tracks.len(),
        measurements.len()
    );
}

/// Test multisensor LMB sensor 1 data association output (r, W) matches MATLAB
#[test]
fn test_multisensor_lmb_sensor1_data_association_equivalence() {
    use multisensor_lmb_filters_rs::lmb::{
        AssociationConfig, Associator, DataAssociationMethod, LbpAssociator,
    };

    let fixture = load_multisensor_lmb_fixture();

    println!("Testing multisensor LMB sensor 1 data association against MATLAB...");

    let sensor_update = &fixture.sensor_updates[1];
    let sensor_idx = sensor_update.sensor_index - 1; // MATLAB uses 1-indexed
    let p_d = sensor_update.input.model_P_d;
    let sensor = model_to_sensor_with_pd(&fixture.model, sensor_idx, p_d);
    let tracks = objects_to_tracks(&sensor_update.input.objects);
    let measurements = measurements_to_dvectors(&sensor_update.input.measurements);

    // Build association matrices
    let mut builder = AssociationBuilder::new(&tracks, &sensor);
    let matrices = builder.build(&measurements);

    // Run LBP data association (deterministic, matches MATLAB)
    let config = AssociationConfig {
        method: DataAssociationMethod::Lbp,
        lbp_max_iterations: 100,
        lbp_tolerance: 1e-3,
        ..Default::default()
    };

    let associator = LbpAssociator;
    let mut rng = rand::thread_rng();
    let result = associator.associate(&matrices, &config, &mut rng).unwrap();

    // Compare against MATLAB using helper
    let expected_da = &sensor_update.data_association;

    // Use helper to compare r and W
    helpers::association::assert_association_result_close(
        &result,
        &expected_da.r,
        &expected_da.w,
        TOLERANCE,
        "Sensor 1 data association",
    );

    println!(
        "  ✓ Multisensor LMB sensor 1 data association (r, W) match MATLAB with TOLERANCE=1e-10"
    );
    println!(
        "    - {} tracks × {} measurements",
        tracks.len(),
        measurements.len()
    );
}

/// Test multisensor LMB final cardinality matches MATLAB
#[test]
fn test_multisensor_lmb_cardinality_equivalence() {
    use multisensor_lmb_filters_rs::lmb::cardinality::lmb_map_cardinality_estimate;

    let fixture = load_multisensor_lmb_fixture();

    println!("Testing multisensor LMB cardinality against MATLAB...");

    let existence_probs = &fixture.step_final_cardinality.input.existence_probs;
    let expected = &fixture.step_final_cardinality.output;

    println!(
        "  Computing MAP cardinality from {} tracks",
        existence_probs.len()
    );

    // Compute MAP cardinality estimate
    let (n_estimated, map_indices) = lmb_map_cardinality_estimate(existence_probs);

    // Compare n_estimated (exact integer match)
    assert_eq!(
        n_estimated, expected.n_estimated,
        "n_estimated: expected {}, got {}",
        expected.n_estimated, n_estimated
    );

    println!("  ✓ n_estimated: {} matches MATLAB", n_estimated);

    // Compare map_indices (MATLAB is 1-indexed, Rust is 0-indexed)
    assert_eq!(
        map_indices.len(),
        expected.map_indices.len(),
        "map_indices length mismatch"
    );

    for (i, (&actual, &expected_val)) in map_indices
        .iter()
        .zip(expected.map_indices.iter())
        .enumerate()
    {
        assert_eq!(
            actual + 1, // Convert 0-indexed to 1-indexed
            expected_val,
            "map_indices[{}]: expected {}, got {} (Rust 0-indexed: {})",
            i,
            expected_val,
            actual + 1,
            actual
        );
    }

    println!(
        "  ✓ map_indices: {:?} match MATLAB (after index conversion)",
        map_indices
    );
    println!("  ✓ Multisensor LMB cardinality matches MATLAB with TOLERANCE=0");
}

/// Test multisensor LMB sensor 0 update output matches MATLAB
#[test]
fn test_multisensor_lmb_sensor0_update_output_equivalence() {
    use multisensor_lmb_filters_rs::lmb::{
        common_ops::update_existence_from_marginals, AssociationConfig, Associator,
        DataAssociationMethod, LbpAssociator, MarginalUpdater, Updater,
    };

    let fixture = load_multisensor_lmb_fixture();

    println!("Testing multisensor LMB sensor 0 update output against MATLAB...");

    let sensor_update = &fixture.sensor_updates[0];
    let sensor_idx = sensor_update.sensor_index - 1; // MATLAB uses 1-indexed
    let p_d = sensor_update.input.model_P_d;
    let sensor = model_to_sensor_with_pd(&fixture.model, sensor_idx, p_d);
    let mut tracks = objects_to_tracks(&sensor_update.input.objects);
    let measurements = measurements_to_dvectors(&sensor_update.input.measurements);

    // Build association matrices
    let mut builder = AssociationBuilder::new(&tracks, &sensor);
    let matrices = builder.build(&measurements);

    // Run LBP data association
    let config = AssociationConfig {
        method: DataAssociationMethod::Lbp,
        lbp_max_iterations: 100,
        lbp_tolerance: 1e-3,
        ..Default::default()
    };

    let associator = LbpAssociator;
    let mut rng = rand::thread_rng();
    let result = associator.associate(&matrices, &config, &mut rng).unwrap();

    // Apply marginal update (using MATLAB-equivalent parameters for multisensor)
    // Multisensor model uses max_components=20 (vs single-sensor's 5)
    let updater = MarginalUpdater::with_thresholds(1e-6, 20, f64::INFINITY);
    updater.update(&mut tracks, &result, &matrices.posteriors);

    // Update existence probabilities
    update_existence_from_marginals(&mut tracks, &result);

    // Compare against MATLAB using helper
    let expected_objects = &sensor_update.output.updated_objects;
    helpers::tracks::assert_tracks_close(&tracks, expected_objects, TOLERANCE);

    println!("  ✓ Multisensor LMB sensor 0 updated_objects match MATLAB with TOLERANCE=1e-10");
    println!("    - {} tracks updated", tracks.len());
}

/// Test multisensor LMB sensor 1 update output matches MATLAB
#[test]
fn test_multisensor_lmb_sensor1_update_output_equivalence() {
    use multisensor_lmb_filters_rs::lmb::{
        common_ops::update_existence_from_marginals, AssociationConfig, Associator,
        DataAssociationMethod, LbpAssociator, MarginalUpdater, Updater,
    };

    let fixture = load_multisensor_lmb_fixture();

    println!("Testing multisensor LMB sensor 1 update output against MATLAB...");

    let sensor_update = &fixture.sensor_updates[1];
    let sensor_idx = sensor_update.sensor_index - 1; // MATLAB uses 1-indexed
    let p_d = sensor_update.input.model_P_d;
    let sensor = model_to_sensor_with_pd(&fixture.model, sensor_idx, p_d);
    let mut tracks = objects_to_tracks(&sensor_update.input.objects);
    let measurements = measurements_to_dvectors(&sensor_update.input.measurements);

    // Build association matrices
    let mut builder = AssociationBuilder::new(&tracks, &sensor);
    let matrices = builder.build(&measurements);

    // Run LBP data association
    let config = AssociationConfig {
        method: DataAssociationMethod::Lbp,
        lbp_max_iterations: 100,
        lbp_tolerance: 1e-3,
        ..Default::default()
    };

    let associator = LbpAssociator;
    let mut rng = rand::thread_rng();
    let result = associator.associate(&matrices, &config, &mut rng).unwrap();

    // Apply marginal update (using MATLAB-equivalent parameters for multisensor)
    // Multisensor model uses max_components=20 (vs single-sensor's 5)
    let updater = MarginalUpdater::with_thresholds(1e-6, 20, f64::INFINITY);
    updater.update(&mut tracks, &result, &matrices.posteriors);

    // Update existence probabilities
    update_existence_from_marginals(&mut tracks, &result);

    // Compare against MATLAB using helper
    let expected_objects = &sensor_update.output.updated_objects;
    helpers::tracks::assert_tracks_close(&tracks, expected_objects, TOLERANCE);

    println!("  ✓ Multisensor LMB sensor 1 updated_objects match MATLAB with TOLERANCE=1e-10");
    println!("    - {} tracks updated", tracks.len());
}

//=============================================================================
// Summary Test
//=============================================================================

#[test]
fn test_multisensor_lmb_matlab_equivalence_summary() {
    println!("\n========================================");
    println!("Multisensor LMB MATLAB Equivalence Tests");
    println!("========================================");
    println!("Testing multisensor LMB filter against MATLAB fixtures");
    println!("Tolerance: {:.0e}", TOLERANCE);
    println!("----------------------------------------\n");
}
